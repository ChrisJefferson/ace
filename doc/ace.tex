%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%W  ace.tex                ACE documentation             Alexander Hulpke
%%
%H  $Id$
%%
%Y  Copyright (C) 1998, School of Math & Comp. Sci., St Andrews, Scotland
%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Chapter{The ACE share package}

The ACE share package permits the user to call the Advanced Coset 
Enumerator written by George Havas and Colin Ramsay from within {\GAP}. 
\index{ace}

\begintt
ACE coset enumerator (C) 1995-1999 by George Havas and Colin Ramsay
    http://www.csee.uq.edu.au/~havas/ace3.tar.gz
\endtt

The {\GAP} interface has been written by Alexander Hulpke.

The package interfaces to an external binary and therefore is only usable
under UNIX. It will not work on Windows or the Macintosh. It requires
{\GAP}~4 in at least beta version 5.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Installing the ACE share package}

To install, unpack the archive file in a directory in the `pkg' hierarchy of
your version of {\GAP}~4. (This might be the `pkg' directory of the
{\GAP}~4 home directory; it is however also possible to keep an additional
`pkg' directory in you private directories, see section "ref:Installing
Share Packages" of the {\GAP}~4 reference manual for details on how to do
this.) Go to the newly created `ACE' directory and call `./configure <path>'
where <path> is the path to the {\GAP} home directory. So for example if you
install the package in the main `pkg' directory call
\begintt
./configure ../..
\endtt
This will fetch the architecture type for which {\GAP} has been compiled last
and create a `Makefile'. 
Now simply call
\begintt
make
\endtt
to compile the binary and to install it in the appropriate place.

If you use this installation of {\GAP} on different hardware platforms you will
have to compile the binary for each platform separately. This is done by
calling `configure' and `make' for the package anew immediately after
compiling {\GAP} itself for the respective architecture.
If your version of {\GAP} is already compiled (and has last been compiled on
the same architecture) you do not need to compile {\GAP}
again, it is sufficient to call the `configure' script in the {\GAP} home
directory.

For details on how to use the `ACE' package see the documentation in the
`doc' subdirectory.

The `src' subdirectory contains a copy of the original source of `ACE'. (The
only modification is that a make-file was copied to `Makefile'.) You can
replace it by a newer version before compiling.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Loading the ACE share package}

To use the `ACE' package you have to request it explicitly. This is done by
calling 
\begintt
gap> RequirePackage("ace");
  Loading the `ACE' share package version 3.0
  Using ACE binary version 3.000
\endtt

If {\GAP} cannot find a working binary, the call to `RequirePackage' will
fail.

If you want to load the `ACE' package by default, you can put this
`RequirePackage' command in your `gaprc' file.

If you want to use the `ACE' coset enumerator as a default for all coset
enumerations done by {\GAP} (which may also get called indirectly), you can 
achieve this by setting the global variable `TCENUM' to `ACETCENUM'.
\begintt
gap> TCENUM:=ACETCENUM;;
\endtt

You
can switch back to the coset enumerator built into the {\GAP} library by
assigning `TCENUM' to `GAPTCENUM'.
\begintt
gap> TCENUM:=GAPTCENUM;;
\endtt


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{The ACE interface}

To call the `ACE' binary directly, you may call

\>ACETCENUM.CosetTableFromGensAndRels(<fgens>,<rels>,<sgens>)

where <fgens> is a list of free generators, <rels> a list of words in these
generators giving relators for a finitely presented group and <sgens>
subgroup generators, again expressed as words in the free generators. The
operation calls the ACE coset enumerator and returns the coset table
obtained or `fail' if the coset enumeration did not finish in the preset
limits. (See section "Options for the ACE enumerator" on how to extend these
limits and how to set enumeration options.)

\begintt
gap> g:=PerfectGroup(2^5*60,2);;
gap> f:=FreeGeneratorsOfFpGroup(g);;
gap> CallACE(f,RelatorsOfFpGroup(g),f{[1,2]});;
\endtt

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Options for the ACE enumerator}

The `ACE' program offers a wide range of options to direct and guide a
coset enumeration. You can use the option mechanism of {\GAP} (see
chapter~"ref:Options Stack" in the reference manual) to pass such options
from {\GAP} to the C standalone. 

Options are also used to specify technical parameters (such as the amount of
memory to be used) or the output format.

By default the ACE coset enumerator chooses strategies that work in many 
cases, however if problems become more complicated you might have to select
specific strategies to get the coset enumeration to finish successfully and
quickly.

The most useful ones for a start are the `easy' option which will lead to a
quick coset enumeration if the problem is easy and the `hard' option if the
coset enumeration is expected to be problematic.
So for example you could call
\begintt
gap> CallACE(f,RelatorsOfFpGroup(g),[]:hard);;
\endtt

While it is possible to set parameters which affect just parts of the
enumeration process, there are also various predefined strategies, which
people have found to be useful. The options `easy' and `hard' we just
mentioned are just two of these, section~"Predefined Strategies" describes
them all.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Options that Alter the ACE Input}

\beginitems
`asis'&
By default, ACE freely and cyclically reduces the relators, freely
  reduces the subgroup generators, and sorts relators and subgroup generators
  in length-increasing order.
If you do not want this, you can switch it off by setting the `asis' option.

*Notes:*
As well as allowing you to use the presentation as it is given, this is
useful for forcing definitions to be made in a prespecified order, by
introducing dummy (i.e., freely trivial) subgroup generators.  Note also
that the exact form of the presentation can have a significant impact on the
enumeration statistics; it is not the case that the default option always
yields the best enumeration.
\enditems

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Options that Modify the Enumeration Process}

The majority of options affect certain aspects of the enumeration process.
Describing them we shall assume that the reader already knows the basic
ideas of coset enumeration, as can be found for example in
\cite{Neu84}.

The first main decision is in which sequence definitions are made:
The order in which cosets are defined is explicitly prescribed by the order
in which (the subgroup generators and) the group
relators are processed in HLT-type procedures. In standard
Felsch-type procedures coset definition is normally from the left/top
of the coset table towards the right/bottom --- that is, in order row by row. 
In fact a procedure needs to follow a method like this to some extent for 
the proofs that coset enumeration eventually terminates in the case of 
finite index.

However this still leaves us with plenty of freedom in definition
strategies, freedom which can be used to great advantage in Felsch-type
methods. Though it is not strictly necessary, Felsch-type programs generally
start off by ensuring that each of the given subgroup generators
forms a cycle at coset 1 before embarking on further enumeration.
The key to performance of coset enumeration procedures is 
good selection of the  next coset to be defined. Thus a preferred
definition strategy is incorporated into our coset table based
definition methods. The detailed control of these mechanisms
is by way of various parameters.

By default ACE uses a strategy which assumes that the enumeration is
easy, and if it turns out not to be so, ACE switches to a strategy
designed for more difficult enumerations. The other straightforward
options for beginning users are "easy" and "hard", and about 10
further predefined strategies are available by name. Details are
to be found in section~"Predefined Strategies".

Thus, easy will quickly succeed or fail (in the context of the
given resources); default may quickly succeed, but then try hard
for a while; hard will more slowly from the beginning try to succeed.

The *enumeration style* is the balance between C-style definitions (i.e.,
coset table based, Felsch style) and R-style definitions (i.e., relator
based, HLT style), and is controlled by the values of the `ct' and `rt'
parameters. These parameters can be set by the following options:
\beginitems
`ct:=<val>'&sets the `ct' parameter

`rt:=<val>'&sets the `rt' parameter
\enditems

The absolute value of these parameters sets the number of
definitions (C-style) or coset applications (R-style) per pass through the
enumerator's main loop.  The sign of these parameters sets the style, and
the possible combinations are given in the following table:

\begintt
RT Value        CT Value        style name
<0              <0              R/C
<0              0               R*
<0              >0              Cr
0               <0              C
0               >0              C
0               0               R/C (default)
>0              <0              Rc
>0              0               R
>0              >0              CR
\endtt

In R style all the definitions are made via relator scans; i.e., this is 
an HLT-like
mode.  In C style most definitions are made in the next empty coset table
slot and are (in principle) tested in all essentially different positions in
the relators; i.e., this is a Felsch-like mode.
However in C-Style some definitions may be made following a preferred
definition strategy, see the `pmode' and `psize' options below.
In R/C style we run in R style until an overflow,
perform a lookahead on the entire table, and then switch to CR style.
Defaulted R/C style is the default style, (here we use R/C style with
`ct' set to 1000 and `rt' set to approximately $2000$ divided by the total
length of the relators) in an attempt to balance R and C definitions when
we switch to CR style.  Rc and Cr styles are like R and C styles, except
that a single C or R style pass (respectively) is done after the initial R
or C style pass.  R\* style makes definitions the same as R style, but tests
all definitions as for C style.  In CR style alternate passes of C style and
R style are performed.

\beginitems
`number:=<val>'&
It is sometimes helpful to include the relators in the subgroup, in the
sense that they are applied to coset \#1 at the start of an enumeration.  A
value of 0 for this option  turns this feature off and the (default) 
argument of -1
includes all the relators.  A positive argument includes the specified
number of relators, in order.
The `number' option affects only the C mode.

`mend'&
Mendelsohn style processing during relator scanning/closing is turned on by
giving this option.  Off is the default, and here coset applications are
done only at the start (and end) of a relator.  Mendelsohn on means that
coset applications are done at all cyclic permutations of the (base)
relator.  The effect of the Mendelsohn parameter is case-specific.  It can
mean the difference between success or failure, or it can impact the number
of cosets required, or it can have no effect on an enumeration's statistics.

*Note:* Processing all cyclic permutations of the relators can be very
time-consuming, especially if the presentation is large.  So, all other
things being equal, the Mendelsohm flag should normally be left off. 

`fill:=<val>'&
Controls the preferred definition strategy by setting the fill factor to
<val>. Unless prevented by the fill factor,
gaps of length one found during deduction testing are
preferentially filled (see \cite{Hav}).  However, this potentially violates
the formal requirement that all rows in the table are eventually filled (and
tested against the relators).  The fill factor is used to ensure that some
constant proportion of the coset table is always kept filled.  Before
defining a coset to fill a gap of length one, the enumerator checks whether
`fill' times the completed part of the table is at least the total size of
the table and, if not, fills coset table rows in standard order instead 
of filling gaps.

An argument of 0 selects the default value of $\lfloor 5(n+2)/4 \rfloor$,
where $n$ is the number of columns in the table.  
This default fill factor allows a moderate amount of gap-filling.
If `fill' is 1, then there is no gap-filling.
This parameter applies only to C-mode.
A large value of `fill' can cause what is in effect infinite looping
(resolved by the coset enumeration failing).
However, in general, a large value does work well.
The effects of the various gap-filling stategies vary widely.  
It is not clear which values are good general defaults or, indeed, whether
  any strategy is always ``not too bad''.

`norow'&This option sets the ``row'' parameter to `false'.
When making HLT-style definitions, it is normal to scan each row of the
  coset table after its coset has been applied to all relators, and make 
  definitions to fill any holes encountered.
Failure to do so can cause even simple enumerations to overflow.
To turn row filling off set the `norow' option.
\enditems

*Lookahead:*
Although HLT-style strategies are fast, they are local, in the
sense that the implications of any definitions/deductions made while
applying cosets may not become apparent until much later.  One way to
alleviate this problem is to perform lookaheads occasionally; that is, to
test the information in the table, looking for deductions or concidences.
ACE can perform a lookahead when the table overflows, before the compaction
routine is called.  Lookahead can be done using the entire table or only
that part of the table above the current coset, and it can be done R-style
(scanning cosets from the beginning of relators) or C-style (testing all
definitions in all essentially different positions).

\beginitems
`look:=<val>'&
sets the value for lookahead to <val>, a value of 0 disables
lookahead.
A value of 1 does a
partial table, R-style lookahead; 2 does all the table, C-style; 3 does all
the table, R-style; and 4 does a partial table, C-style.  The default is
either 0 or 1 depending on the strategy, see Section~"Predefined Strategies".
\enditems

*Deductions:*
A completed table is only valid if every table entry has been tested in all
essentially different positions in all relators.  This testing can either be
done directly (Felsch strategy) or via relator scanning (HLT strategy).  If
it is done directly, then more than one deduction (i.e., table entry) can be
outstanding at any one time.  So the untested deductions are stored in a
stack.  Normally this stack is fairly small but, during a collapse, it can
become very large.

\beginitems
`dmode:=<val>'&
sets the deduction mode to <val>.  This allows the user to specify how
deductions should be handled.  The value <val> has the following
interpretations: 0 discard deductions if there is no stack space left; in
addition purges redundant cosets off the top of the stack at every
coincidence. 
2: again is as 0,
but purges all redundant cosets from the stack at 
every coincidence.
3: discard the entire stack if it overflows;
4: if the stack overflows, then double the stack size and purge all
  redundant cosets from the stack.

The default deduction mode is either $0$ or $4$, depending on the strategy
selected (see section~"Predefined Strategies"), and it is recommended that
you stay with the default.  If you want to know more details, read the code.

*Notes:*
If deductions are discarded for any reason, then a final relator
check phase will
be run automatically at the end of the enumeration, if necessary, to check
the result.

`dsize:=<val>'&
Sets the size of the (initial) allocation for the deduction stack to <val>.
The size is in terms of the number of deductions, with one deduction
  taking two words (i.e., 8 bytes).
The default size, of $1000$, can be selected by a value of 0.
See the `dmode' entry for a (brief) discussion of deduction handling.

`pmode:=<val>'&The value of the `pmode' option determines which definitions
are preferred.  If the argument is 0, then Felsch style definitions are made
using the next empty table slot.  If the argument is non-zero, then gaps of
length one found during relator scans in Felsch style are preferentially
filled (subject to the value of `fill').  If the argument is 1, they are
filled immediately, and if it is 2, the consequent deduction is also made
immediately (of course, these are also put on the deduction stack).  If the
argument is 3, then the gaps of length one
are noted in the preferred definition queue.
Provided a live such gap survives (and no coincidence occurs, which causes
the queue to be discarded) the next coset will be defined to fill the oldest
gap of length one.  The default value is either 0 or 3, depending on the
strategy selected (see section~"Predefined Strategies").  If you want to
know more details, read the code.

`psize:=<val>'&
The preferred definition queue is implemented as a ring, dropping
  earliest entries.
Its size *must* be $2^n$, for some $n>0$.
An argument of 0 selects the default size of $256$.
Each queue slot takes two words (i.e., 8 bytes), and the queue can store
  up to $2^n-1$ entries.

\enditems

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Predefined Strategies}

The versatility of ACE means that it can be difficult to select appropriate
parameters when presented with a new enumeration.  The problem is compounded
by the fact that no generally applicable rules exist to predict, given a
presentation, which parameter settings are ``good''.  To help overcome this
problem, ACE contains various commands which select particular enumeration
strategies.  One or other of these strategies may work and, if not, the
results may indicate how the parameters can be varied to obtain a successful
enumeration.  The thirteen standard strategies are listed below, their
definition is given in the table below.

The various parameters available via {\GAP} are explained in groups according
to their functionality. The parameter names are listed in the top row
and the strategy names are in the first column.

\begintt
       path row mend number  look com  ct   rt   fill pmode psize dmode dsize 
default n    y   n     -1     0   10   0    0      0    3    256    4    1000
easy    n    y   n      0     0   100  0    1000   1    0    256    0    1000
hard    n    y   n     -1     0   10   1000 1      0    3    256    4    1000
felsch0 n    n   n     0      0   10   1000 0      1    0    256    4    1000
felsch1 n    n   n     -1     0   10   1000 0      0    3    256    4    1000
hlt     n    y   n     0      1   10   0    1000   1    0    256    0    1000
purec   n    n   n     0      0   100  1000 0      1    0    256    4    1000
purer   n    n   n     0      0   100  0    1000   1    0    256    0    1000
sims1   n    y   n     0      0   10   0    1000   1    0    256    0    1000
sims3   n    y   n     0      0   10   0    -1000  1    0    256    4    1000
sims5   n    y   y     0      0   10   0    1000   1    0    256    0    1000
sims7   n    y   y     0      0   10   0    -1000  1    0    256    4    1000
sims9   n    n   n     0      0   10   1000 0      1    0    256    4    1000
\endtt
(The `row' column gives the negatiopn of the `norow' option, i.e. `row=n'
meand `norow=y' and vice versa.)

Note that, apart from the `felsch0' and `sims9' strategies, all of the
strategies are distinct, although some are very similar.

Styles are selected by giving option:

\beginitems
`default':&
This selects the default strategy, which is based on the defaulted R/C
style; see section~"Options that Modify the Enumeration Process".  The idea
here is that we assume that the enumeration is ``easy'' and start out in R
style.  If it turns out not to be easy, then we regard it as ``hard'', and
switch to CR style, after performing a lookahead on the entire table.

`easy':&
If this strategy is selected, we run in R style (i.e., HLT) and turn
lookahead and compaction off.  For small and/or easy enumerations, this mode
is likely to be the fastest.

`hard':&
If this strategy is selected, we run in R style (i.e., HLT) and turn In many
`hard' enumerations, a mixture of R-style and C-style definitions, all
tested in all essentially different positions, is appropriate.  This option
selects such a mixed strategy.  The idea here is that most of the work is
done C-style (with the relators in the subgroup and with gap-filling
active), but that every $1000$ C-style definitions a further coset is
applied to all relators.

*Guru Notes:*
The `1000/1' mix is not necessarily optimal, and some
  experimentation may be needed to find an acceptable balance (see, for
  example, \cite{HR1}).
Note also that, the longer the total length of the presentation, the more
  work needs to be done for each coset application to the relators; one
  coset application can result in more than $1000$ definitions, reversing
  the balance between R-style and C-style definitions.

`felsch0',`felsch1':&
`felsch0' selects the Felsch strategy, while `felsch1' selects Felsch with all
relators in the subgroup and turns gap-filling on.

`hlt':&
Selects the standard HLT strategy.

`purec':&
Sets the strategy to basic C-style (coset table based) -- no compaction, no
gap-filling, no relators in subgroup.

`purer':&
Sets the strategy to basic R-style (relator based) -- no Mendelsohn, no
compaction, no lookahead, no row-filling.

`sims1',`sims3',`sims5',`sims7',`sims9':&
In his book \cite{Sim}, Sims discusses ten standard enumeration strategies.
These are effectively HLT (with and without the `mend' parameter) and
Felsch, all either with or without table standardisation as the enumeration
proceeds.
%%  ACE does not implement table standardisation during an enumeration, 
%%  although incomplete tables can be standardised and an enumeration
%%  continued.
The other five strategies are implemented, and can be selected by these
options.  The number is the same as given in \S5.5~of~\cite{Sim}.  With
care, it is possible to duplicate the statistics given in \cite{Sim}; some
examples are given in the ACE manual.

\enditems

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Technical Options for ACE}

The following options do not affect how the coset enumeration is done, but
how it uses the computers resources. They might thus affect the runtime as
well as the range of problems that can be tackled on a given machine.

\beginitems
`workspace:=<val>'&Sets the size of the workspace in words.
The default is 200000. 
The number of cosets in the table is the table size divided by the number of
columns.  Although the number of cosets is limited to $2^{31}-1$ (if the C
`int' type is 32 bits), the table size can exceed the $4$GByte 32-bit limit
if a suitable machine is used.

The actual number of cosets in the table is size$/4 -2$, rounded down to the
nearest integer.  The $-2$ is to allow for possible rounding errors and the
fact that coset number 0 is not used.

`time:=<val>'&Sets maximum execution time in seconds.
The default is 0 which is no time limit.
If the argument is $\ge0$ then the total elapsed time for this call is
checked at the end of each pass through the enumerator{\pif}s main loop, and
if it's more than the limit the run is stopped and the current table
returned.
%
The time limit is approximate, in the sense that the enumerator may run for
a longer, but never a shorter, time.  So, if there is, e.g., a big collapse
(so that the time round the loop becomes very long), then the run may run
over the limit by a large amount.

*Notes:*
The time limit is CPU-time, not wall-time.
As in all timing under Unix, the clock's granularity (usually $10$ mSec)
  and the system load can affect the timing; so the number of main loop
  iterations in a given time may vary.

`path'&Turns path compression on or off.
To correctly process multiple concidences, a union-find must be performed.
If both path compression and weighted union are used, then this can be
  done in essentially linear time (see, e.g., \cite{CLR}).
Weighted union alone, in the worst-case, is worse than linear, but is
  subquadratic.
In practice, path compression is expensive, since it involves many coset
  table accesses.
So, by default, path compression is turned off.
It has no effect on the result, but may effect the running time and the
  internal statistics.

*Notes:*
The whole question of the best way to handle large coincidence forests is
  problematic.
Formally, ACE does not do a weighted union, since it is constrained to
  replace the higher-numbered of a coincident pair.
In practice, this seems to amount to much the same thing!
Turning path compression on cuts down the amount of data movement during
  coincidence processing at the expense of having to trace the paths and
  compress them.
In general, it does not seem to be worthwhile.

`com:=<val>'&Sets the percentage of dead cosets needed to trigger
compaction. The default is 10 or 100, depending on the strategy used
(see section~"Predefined Strategies").

Compaction recovers the space allocated to cosets which are flagged as dead
(i.e., which were found to be coincident with lower-numbered cosets).  It
results in a table where all the active cosets are numbered contiguously
from number 1, and with the remainder of the table available for new cosets.

The coset table is compacted when a coset definition is required, there is
no space for a new coset available, and provided that the given percentage
of the coset table contains dead cosets.  A value of 100 means that
compaction is never performed, while a value of 0 means always compact,
no matter how few dead cosets there are (provided there is at least one, of
course).

Compaction may be performed multiple times during an enumeration, and the
table that results from an enumeration may or may not be compact, depending
on whether or not there have been any coincidences since the last compaction
(or from the start of the enumeration, if there have been no compactions).

If messaging is enabled (see~"Information About the Enumeration"), then a
progress message (labelled `CO') is printed each time the compaction routine
is actually called (as opposed to each time it is potentially called).

*Notes:*
In some strategies (e.g., HLT) a lookahead phase may be run before
compaction is attempted.  In other strategies (e.g., `Sims3') compaction may
be performed while there are outstanding deductions; since deductions are
discarded during compaction, a final `RA' phase will (automatically) be
performed.
%
Compacting a table ``destroys'' information and history, in the sense that
the coincidence list is deleted, and the table entries for any dead cosets
are deleted.  At Level 2, it is not possible to access the ``data'' in dead
cosets; in fact, most options that require table data compact the table
automatically before they run.

`max:=<nr>'&Sets the maximum number of cosets to be defined.
By default, all of the workspace is used, if necessary, in building the
coset table.  So the table size is an upper bound on how many cosets can be
active at any one time.  The `max' option allows a limit to be placed on how
much of the physical table space is made available to the enumerator.
Enough space for at least two cosets (i.e., the subgroup and one other) must
be made available.  An argument of 0 selects all of the workspace.
\enditems

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Information About the Enumeration and Experiments}

\beginitems
`mess'&Displays the output of `ACE' on screen. By assigning `mess' to
integers, the internal message level of `ACE' is changed.

`messfile:=<fnam>'&
If this option is given, all message output is directed to file <fnam>
instead of the screen.

`aep:=<val>'&
This (all equivalent presentations) option runs an enumeration for each
possible combination of relator ordering, relator rotations, and relator
inversions and should be used in conjunction with the `mess' or `messfile'
option.

As discussed by Cannon, Dimino, Havas and Watson \cite{CDHW} and Havas
  and Ramsay \cite{HR1} such equivalent presentations can yield large
  variations in the number of cosets required in an enumeration.
For this command, we are interested in this variation.

The `aep' option first performs a ``priming run'' using the parameters
  as they stand.
In particular, the `asis' and `mess' parameters are honoured.
It then turns `asis' on and `mess' off, and generates and tests
  the requested equivalent presentations.
The maximum and minimum values attained by `maxcos' and `totcos'
  are tracked, and each time a new `record' is found the relators used and
  the summary result line is printed.
At the end, some additional status information is printed: 
  the number of runs which yielded a finite index; 
  the total number of runs (excluding the priming run); 
  and the range of values observed for `maxcos' and `totcos'.
The mandatory argument is considered as a binary number.
Its three bits are treated as flags, and control relator rotations (the
  $2^0$ bit), relator inversions (the $2^1$ bit) and relator orderings
  (the $2^2$ bit); ``1'' means `active' and ``0'' means
  ``inactive''.
The order in which the equivalent presentations are generated and tested
  has no particular significance.

`rep:=<val>'&
The `rep' (random equivalent presentations) option complements the
  `aep' option.
It generates and tests some random equivalent presentations.
The mandatory argument acts as for `aep'.
It is also possible to set the number of presentations used (a default of
eight) by using the extended syntax `rep:=[<val>,<number>]'. 

The routine first turns `asis' on and `mess' off, and then 
  generates and tests the requested equivalent presentations.
For each presentation the relators used and the summary result line are
  printed.

*Notes:*
The relator inversions and rotations are ``genuinely'' random.
The relator permuting is a little bit of a kludge, with the ``quality'' of
  the permutations tending to improve with successive presentations. 

\enditems

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Section{Examples of ACE Calls with Options}

The following example calls ACE for up to 500 cosets using
Mendelsohn style relator processing and sets the message level to 200
\begintt
gap> CallACE(f,RelatorsOfFpGroup(g),f{[1]}:mendelsohn,max:=500,mess:=200);;
Start ACE v1.1 on Fri Oct  9 14:55:49 1998

Enumeration: G
Group Generators: abcdefg;
Group Relators: (c)^2, (d)^2, (e)^2, (f)^2, (g)^2, aaG, (b)^3, (CD)^2, 
  (EF)^2, (CE)^2, (CF)^2, (DE)^2, (DF)^2, AcaE, AdaF, AeaC, AfaD, BfbE, 
  GAga, GBgb, (GC)^2, (GD)^2, (GE)^2, (GF)^2, BebFE, BcbGFD, BdbFEDC, 
  (ab)^5;
Subgroup name: H
Subgroup Generators: a;
Max=500 CTF=0 RTF=0 FillF=13 NRinS=0 Mendel=1 Adapt=0
RD a=200 m=200 t=234 knr=29 knc=1 cpu=0.00
RD a=400 m=400 t=486 knr=68 knc=1 cpu=0.01
CO a=296 m=407 t=500 knr=67 knc=158 cpu=0.03
INDEX = 480  (MAX=480 TOT=684 KNR=67 KNC=481 CPU=0.06)
#DEF: gap=183 knc=1 ff=0 dead pdl=0; knr=499 fill=0 (sg=46)
#GAP: tot=2714 full=1082 #DED: CT=811 RT=605 LA=366 discarded=23***
#COINC: CT=0 RT=74 LA=65 ap=1
\endtt

If `ACE' is made the standard coset enumerator the same method of passing
arguments may be used with all other commands and will affect coset
enumerations. As an example we use the `ACE' enumerator to compute the
permutation representation of a perfect group from the data library:

\begintt
gap> TCENUM:=ACETCENUM;;
gap> PerfectGroup(IsPermGroup,16*60,1:max:=[50,500,40],mess);
Start ACE 2.000 on Fri Oct 23 10:09:53 1998
host name: muir

Enumeration: G;
INDEX = 16 (MAX=30 TOT=35 KNR=36 KNC=1 CPU=0.00)
INDEX = 16 (MAX=30 TOT=35 KNR=36 KNC=1 CPU=0.00)
INDEX = 16 (MAX=30 TOT=35 KNR=36 KNC=1 CPU=0.00)
INDEX = 16 (MAX=30 TOT=35 KNR=36 KNC=1 CPU=0.00)
INDEX = 16 (MAX=30 TOT=35 KNR=36 KNC=1 CPU=0.00)
INDEX = 16 (MAX=30 TOT=35 KNR=36 KNC=1 CPU=0.00)
INDEX = 16 (MAX=30 TOT=35 KNR=36 KNC=1 CPU=0.01)
INDEX = 16 (MAX=30 TOT=35 KNR=36 KNC=1 CPU=0.00)
INDEX = 16 (MAX=30 TOT=35 KNR=36 KNC=1 CPU=0.00)
INDEX = 16 (MAX=30 TOT=35 KNR=36 KNC=1 CPU=0.00)
INDEX = 16 (MAX=30 TOT=35 KNR=36 KNC=1 CPU=0.00)
INDEX = 16 (MAX=30 TOT=35 KNR=36 KNC=1 CPU=0.00)
A5 2^4
\endtt
